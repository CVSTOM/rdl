#!/usr/bin/env ruby


 require 'rdl'
 require 'rdl_types'

MAX_FIXNUM = 2**(0.size*8-2)-1 #Largest fixnum. -2 since 1 bit used for sign, 1 bit used as int marker.
MIN_FIXNUM = -(2**(0.size*8-2)) #Smallest fixnum.

 def test()
	x = gen_number()
	type_one = x.class.to_s

	y = gen_number()
	type_two = y.class.to_s

	operation_type = query(type_one+'#-',y)
	expected_type = operation_type[operation_type.index('->')+3..-1]
	w = x+y
	test_result = w.is_a?(Object.const_get(expected_type))
	if !test_result
		puts "Arg1= #{x}"
		puts "Arg2= #{y}"
		puts "Res= #{w}"
		puts "Expected type: #{expected_type}"
		puts "Received type: #{w.class}"
	end
 	return test_result
 end

def gen_number()
	r = Random.rand()
	p = Random.rand()
	if r<0.25 then
		#Fixnum type
		x = Random.rand(MIN_FIXNUM..MAX_FIXNUM)

	elsif r<0.5
		#Bignum type
		if p<0.5
			x = Random.rand(MAX_FIXNUM+1..MAX_FIXNUM*1000)
		else
			x = -1*Random.rand(MAX_FIXNUM+1..MAX_FIXNUM*1000)
		end
	elsif r<0.55
		x=Float::INFINITY
	elsif r<0.6
		x=Float::NAN
	elsif r<0.65
		x=Float::MIN
	elsif r<0.7
		x=Float::MAX
	else
		#Random Float type
		x = (2**32)*Random.rand
		if p<0.5
			x = (2**32)*Random.rand
		else
			x = -1*(2**32)*Random.rand
		end
	end
	return x
end

 def rounds(x)
	counter = 0
	for i in 0..x
		b= test()
		if (!b) then
			counter=counter+1
		end
	
	end
	return counter
 end	


def query(q,y)
    $__rdl_contract_switch.off {
      if q =~ /^(\w+(#|\.))?(\w+(!|\?|=)?|!|~|\+|\*\*|-|\*|\/|%|<<|>>|&|\||\^|<|<=|=>|>|==|===|!=|=~|!~|<=>|\[\]|\[\]=)$/
        klass = nil
        klass_pref = nil
        meth = nil
        if q =~ /(.+)#(.+)/
          klass = $1
          klass_pref = "#{klass}#"
          meth = $2.to_sym
        elsif q =~ /(.+)\.(.+)/
          klass_pref = "#{$1}."
          klass = RDL::Util.add_singleton_marker($1)
          meth = $2.to_sym
        else
          klass = self.class.to_s
          klass_pref = "#{klass}#"
          meth = q.to_sym
        end
        if RDL::Wrap.has_contracts?(klass, meth, :type)
          typs = RDL::Wrap.get_contracts(klass, meth, :type)
          typs.each { |t|
            #puts "#{klass_pref}#{meth}: #{t}"
	    t_string = "#{t}"
	    t_string =~ /\((\w*)\)(.+)/
	    puts t_string
	    if $1.length==0
		puts "got it"
	    end
	    if $1!=""
		#catch negative sign case
	    	if y.is_a?(Object.const_get($1))
			return t_string
		end
	    end
	    #return "#{t}" 
          }
          
        else
          #puts "No type for #{klass_pref}#{meth}"
        end
      else
        #puts "Not implemented"
      end
    }
  end

