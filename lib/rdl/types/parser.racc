class Parser
  prechigh
    left COMMA
    right RARROW
    left OR
  preclow

  start entry

token DOUBLE_HASH CONST_BEGIN
token OR ASSOC FIXNUM FLOAT COLON RARROW ID SYMBOL SPECIAL_ID STRING
token LPAREN RPAREN LBRACE RBRACE LBRACKET RBRACKET
token COMMA QUERY STAR LESS GREATER
token EOF

rule

  entry:
      method_type { result = val[0] }
    | bare_type { result = val[0] }

  bare_type:
      DOUBLE_HASH type_expr {
        result = val[1]
      }

  method_type:
      LPAREN arg_list RPAREN block RARROW type_expr {
        result = RDL::Type::MethodType.new val[1], val[3], val[5]
      }
   | LPAREN arg_list RPAREN block RARROW ID COLON type_expr {
        result = RDL::Type::MethodType.new val[1], val[3], RDL::Type::NamedArgType.new(val[5], val[7])
      }


  arg_list:
      { result = [] }
    | arg { result = [val[0]] }
    | arg COMMA arg_list { if val[2] then result = val[2].unshift val[0] else val[0] end }
  arg:
      base_arg { result = val[0] }
    | ID COLON base_arg { result = RDL::Type::NamedArgType.new(val[0], val[2]) }

  base_arg:
      QUERY type_expr { result = RDL::Type::OptionalType.new val[1] }
    | STAR type_expr { result = RDL::Type::VarargType.new val[1] }
    | type_expr { result = val[0] }

  block:
      { result = nil }
    | LBRACE method_type RBRACE { result = val[1] }

  type_expr:
    union_type { result = val[0] }
  | LPAREN type_expr RPAREN { result = val[1] }

  type_expr_comma_list:
      type_expr { result = [val[0]] }
    | type_expr COMMA type_expr_comma_list {
        result = [val[0]] + val[2] }

  union_type:
    single_type { result = val[0] }
  | single_type OR union_type { result = RDL::Type::UnionType.new val[0], val[2] }

  single_type:
      SYMBOL { result = RDL::Type::SingletonType.new(val[0].to_sym) }
    | ID {
      if val[0] == 'nil' then
        result = RDL::Type::NilType.new
      elsif val[0] =~ /^[a-z_]+\w*\'?/ then
        result = RDL::Type::VarType.new(val[0].to_sym)
      else
        result = RDL::Type::NominalType.new val[0]
      end
    }
    | SPECIAL_ID {
      if $__rdl_special_types.has_key? val[0] then
        result = $__rdl_special_types[val[0]]
      else
        fail "Unexpected special type identifier #{val[0]}"
      end
    }
    | ID LESS type_expr_comma_list GREATER { 
      n = RDL::Type::NominalType.new(val[0])
      result = RDL::Type::GenericType.new(n, *val[2])
    }
    | LBRACKET type_expr_comma_list RBRACKET {
      result = RDL::Type::TupleType.new(*val[1])
    }
    | FIXNUM { result = RDL::Type::SingletonType.new(val[0].to_i) }
    | FLOAT { result = RDL::Type::SingletonType.new(val[0].to_f) }
    | CONST_BEGIN ID RBRACE { result = RDL::Type::SingletonType.new(Kernel.const_get val[1]) }


---- header ----

require_relative 'lexer.rex'

module RDL::Type

---- inner ----

def initialize()
  @yydebug = true
end

---- footer ----

end
