require 'rdl'
require 'Set'

class Set
  extend RDL 

  ## Class Methods
  #typesig(:[])

  ## Instance Methods
  typesig(:&, "(Enumerable) -> Set") 
  typesig(:+, "(Enumerable) -> Set") 
  typesig(:-, "(Enumerable) -> Set") 
  typesig(:<, "(Set) -> %bool") 
  typesig(:<<, "(%any) -> Set") 
  typesig(:<=, "(Set) -> %bool") 
  typesig(:==, "(%any) -> %bool") 
  typesig(:>, "(Set) -> %bool") 
  typesig(:>=, "(Set) -> %bool") 
  typesig(:^, "(Enumerable or NilClass) -> Set") 
  typesig(:add, "(%any) -> Set") 
  typesig(:add?, "(%any) -> Set") 
  typesig(:classify, "() -> Enumerator") 
  typesig(:classify, "() {(t) -> %any} -> Set<Set>", :vars => [:t]) 
  typesig(:clear, "() -> Set") 
  typesig(:collect!, "() -> Enumerator") 
  typesig(:collect!, "() {(%any) -> t} -> Set<t>", :vars => [:t]) 
  typesig(:delete, "(%any) -> Set") 
  typesig(:delete?, "(%any) -> Set or NilClass") 
  typesig(:delete_if, "() -> Enumerator") 
  typesig(:delete_if, "() {(%any) -> %bool} -> Set") 
  typesig(:difference, "(Enumerable) -> Set") 
  typesig(:disjoint?, "(Set) -> %bool") 
  typesig(:divide, "() -> Enumerator") 
  typesig(:divide, "() {(%any,%any) -> %any} -> Set<Set>") 
  typesig(:each, "() -> Enumerator") 
  typesig(:each, "() {(%any) -> %any} -> %any") 
  typesig(:empty?, "() -> %bool") 
  typesig(:eql?, "(%any) -> %bool") 
  typesig(:flatten, "() -> Set") 
  typesig(:flatten!, "() -> Set or NilClass") 
  typesig(:freeze, "() -> Set") 
  typesig(:hash, "() -> Integer") 
  typesig(:include?, "(%any) -> %bool") 
  typesig(:inspect, "() -> String") 
  typesig(:intersect?, "(Set) -> %bool") 
  typesig(:intersection, "(Enumerable) -> Set") 
  typesig(:keep_if, "() -> Enumerator") 
  typesig(:keep_if, "() {(%any) -> %bool} -> Set") 
  typesig(:length, "() -> Integer") 
  typesig(:map!, "() -> Enumerator") 
  typesig(:map!, "() {(%any) -> t} -> Set<t>", :vars => [:t]) 
  typesig(:member?, "(%any) -> %bool") 
  typesig(:merge, "(Enumerable) -> Set") 
  typesig(:proper_subset?, "(Set) -> %bool") 
  typesig(:proper_superset?, "(Set) -> %bool") 
  typesig(:reject!, "() -> Enumerator") 
  typesig(:reject!, "() {(%any) -> %bool} -> Set") 
  typesig(:replace, "(Enumerable) -> Set") 
  typesig(:select!, "() -> Enumerator") 
  typesig(:select!, "() {(%any) -> %bool} -> Set") 
  typesig(:size, "() -> Integer") 
  typesig(:subset?, "(Set) -> %bool") 
  typesig(:subtract, "(Enumerable) -> Set") 
  typesig(:superset?, "(Set) -> %bool") 
  typesig(:taint, "() -> Set") 
  typesig(:to_a, "() -> Array") 
  typesig(:to_set, "() -> Set") 
  typesig(:to_set, "(?Class, *%any) {(%any) -> %any} -> Set")
  typesig(:union, "(Enumerable) -> Set") 
  typesig(:untaint, "() -> Set") 
  typesig(:|, "(Enumerable) -> Set") 
end
