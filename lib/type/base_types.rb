require 'rdl'

class Array
  extend RDL
  type_params [:t, :each]
  
  typesig(:[], "(Range) -> Array<t>")
  typesig(:[], "(Fixnum) -> t")
  typesig(:[], "(Fixnum, Fixnum) -> Array<t>")
  typesig(:[], "(Float) -> t")
  typesig(:&, "(Array<u>) -> Array<t>", :vars => [:u])
  typesig(:*, "(Fixnum) -> Array<t>")
  typesig(:*, "(String) -> String")
  typesig(:+, "(Array<u>) -> Array<u or t>", :vars => [:u])
  typesig(:-, "(Array<u>) -> Array<u or t>", :vars => [:u])
  typesig(:slice, "(Range) -> Array<t>")
  typesig(:slice, "(Fixnum) -> t")
  typesig(:slice, "(Fixnum, Fixnum) -> Array<t>")
  typesig(:[]=, "(Fixnum, t) -> t")
  typesig(:[]=, "(Fixnum, Fixnum, t) -> t")
  #typesig(:[]=, "(Fixnum, Fixnum, Array<t>) -> Array<t>")
  #typesig(:[]=, "(Range, Array<t>) -> Array<t>")
  typesig(:[]=, "(Range, t) -> t")
  typesig(:assoc, "(t) -> Array<t>")
  typesig(:at, "(Fixnum) -> t")
  typesig(:clear, "() -> Array<t>")
  typesig(:map, "() {(t) ->u} -> Array<u>", :vars => [:u])
  typesig(:map, "() -> Enumerator", :vars => [:u])
  typesig(:collect, "() { (t) -> u } -> Array<u>", :vars => [:u])
  typesig(:collect, "() -> Enumerator")
  typesig(:combination, "(Fixnum) { (Array<t>) -> %any } -> Array<t>")
  typesig(:combination, "(Fixnum) -> Enumerator")
  typesig(:push, "(t) -> Array<t>")  
  typesig(:compact, "() -> Array<t>")
  typesig(:compact!, "() -> Array<t>")
  typesig(:concat, "(Array<t>) -> Array<t>")
  typesig(:count, "() -> Fixnum")
  typesig(:count, "(t) -> Fixnum")
  typesig(:count, "() { (t) -> %bool } -> Fixnum")
  typesig(:cycle, "(?Fixnum) { (t) -> %any } -> %any")
  typesig(:cycle, "(?Fixnum) -> Enumerator")
  typesig(:delete, "(u) -> t", :vars => [:u])
  typesig(:delete, "(u) { () -> v } -> t or v", :vars => [:u, :v])
  typesig(:delete_at, "(Fixnum) -> Array<t>")
  typesig(:delete_if, "() { (t) -> %bool } -> Array<t>")
  typesig(:delete_if, "() -> Enumerator")
  typesig(:drop, "(Fixnum) -> Array<t>")
  typesig(:drop_while, "() { (t) -> %bool } -> Array<t>")
  typesig(:drop_while, "() -> Enumerator")
  typesig(:each, "() -> Enumerator")
  typesig(:each, "() { (t) -> %any } -> Array<t>")
  typesig(:each_index, "() { (Fixnum) -> %any } -> Array<t>")
  typesig(:each_index, "() -> Enumerator")
  typesig(:empty?, "() -> %bool")
  typesig(:fetch, "(Fixnum) -> t")
  typesig(:fetch, "(Fixnum, u) -> u", :vars => [:u])
  typesig(:fetch, "(Fixnum) { (Fixnum) -> u } -> t or u", :vars => [:u])
  typesig(:fill, "(t) -> Array<t>")
  typesig(:fill, "(t,Fixnum,?Fixnum) -> Array<t>")
  typesig(:fill, "(t, Range) -> Array<t>")
  typesig(:fill, "() { (Fixnum) -> t } -> Array<t>")
  typesig(:fill, "(Fixnum,?Fixnum) { (Fixnum) -> t } -> Array<t>")
  typesig(:fill, "(Range) { (Fixnum) -> t } -> Array<t>")
  typesig(:index, "(u) -> Fixnum", :vars => [:u])
  typesig(:index, "() { (t) -> %bool } -> Fixnum")
  typesig(:index, "() -> Enumerator")
  typesig(:first, "() -> t")
  typesig(:first, "(Fixnum) -> Array<t>")
  typesig(:include?, "(u) -> %bool", {:vars => [:u]})
  typesig(:insert, "(Fixnum, *t) -> Array<t>")
  typesig(:to_s, "() -> String")
  typesig(:inspect, "() -> String")
  typesig(:join, "(?String) -> String")
  typesig(:keep_if, "() { (t) -> %bool } -> Array<t>")
  typesig(:last, "() -> t")
  typesig(:last, "(Fixnum) -> Array<t>")
  typesig(:length, "() -> Fixnum")
  typesig(:permutation, "(?Fixnum) -> Enumerator")
  typesig(:permutation, "(?Fixnum) { (Array<t>) -> %any } -> Array<t>")
  typesig(:pop, "(Fixnum) -> Array<t>")
  typesig(:pop, "() -> t")
  typesig(:product, "(*Array<u>) -> Array<Array<t or u>>", :vars => [:u])
  typesig(:rassoc, "(u) -> t", :vars => [:u])
  typesig(:reject, "() { (t) -> %bool } -> Array<t>")
  typesig(:reject, "() -> Enumerator")
  typesig(:reject!, "() { (t) -> %bool } -> Array<t>")
  typesig(:reject!, "() -> Enumerator")
  typesig(:repeated_combination, "(Fixnum) { (Array<t>) -> %any } -> Array<t>")
  typesig(:repeated_combination, "(Fixnum) -> Enumerator")
  typesig(:repeated_permutation, "(Fixnum) { (Array<t>) -> %any } -> Array<t>")
  typesig(:repeated_permutation, "(Fixnum) -> Enumerator")
  typesig(:reverse, "() -> Array<t>")
  typesig(:reverse!, "() -> Array<t>")
  typesig(:reverse_each, "() { (t) -> %any } -> Array<t>")
  typesig(:reverse_each, "() -> Enumerator")
  typesig(:rindex, "(u) -> t", :vars => [:u])
  typesig(:rindex, "() { (t) -> %bool } -> Fixnum")
  typesig(:rindex, "() -> Enumerator")
  typesig(:rotate, "(?Fixnum) -> Array<t>")
  typesig(:rotate!, "(?Fixnum) -> Array<t>")
  typesig(:sample, "() -> t")
  typesig(:sample, "(Fixnum) -> Array<t>")
  typesig(:select, "() { (t) -> %bool } -> Array<t>")
  typesig(:select, "() -> Enumerator")
  typesig(:select!, "() { (t) -> %bool } -> Array<t>")
  typesig(:select!, "() -> Enumerator")
  typesig(:shift, "() -> t")
  typesig(:shift, "(Fixnum) -> Array<t>")
  typesig(:shuffle, "() -> Array<t>")
  typesig(:shuffle!, "() -> Array<t>")
  typesig(:size, "() -> Fixnum")
  typesig(:slice, "(Range) -> Array<t>")
  typesig(:slice, "(Fixnum, Fixnum) -> Array<t>")
  typesig(:slice, "(Fixnum) -> t")
  typesig(:slice, "(Float) -> t")
  typesig(:slice!, "(Range) -> Array<t>")
  typesig(:slice!, "(Fixnum, Fixnum) -> Array<t>")
  typesig(:slice!, "(Fixnum) -> t")
  typesig(:slice!, "(Float) -> t")
  typesig(:sort, "() -> Array<t>")
  typesig(:sort, "() { (t,t) -> Fixnum } -> Array<t>")
  typesig(:sort!, "() -> Array<t>")
  typesig(:sort!, "() { (t,t) -> Fixnum } -> Array<t>")
  typesig(:sort_by!, "() { (t) -> u } -> Array<t>", {:vars => [:u]})
  typesig(:sort_by!, "() -> Enumerator")
  typesig(:take, "(Fixnum) -> Array<t>")
  typesig(:take_while, "() { (t) ->%bool } -> Array<t>")
  typesig(:take_while, "() -> Enumerator")
  typesig(:to_a, "() -> Array<t>")
  typesig(:to_ary, "() -> Array<t>")
  typesig(:transpose, "() -> Array<t>")
  typesig(:uniq, "() -> Array<t>")
  typesig(:uniq!, "() -> Array<t>")
  typesig(:unshift, "(*t) -> Array<t>")
  typesig(:values_at, "(*Range or Fixnum) -> Array<t>")
  typesig(:zip, "(*Array<u>) -> Array<Array<t or u>>", {:vars => [:u]})
  typesig(:|, "(Array<u>) -> Array<t or u>", {:vars => [:u]})
end

class Hash
  extend RDL
  type_params [:k, :each_key], [:v, :each_value]

  typesig(:[], "(k) -> v")
  typesig(:[]=, "(k, v) -> v")
  typesig(:store, "(k,v) -> v")

  # TODO: Tuple does not work completely, seems like it didn't work completely in RTC
  # typesig(:assoc, "(k) -> Tuple<k,v>")
  typesig(:assoc, "(k) -> Array<k or v>")
  typesig(:clear, "() -> Hash<k,v>")
  typesig(:compare_by_identity, "() -> Hash<k,v>")
  typesig(:compare_by_identity?,  "() -> %bool")
  typesig(:default, "(?k) -> v")
  typesig(:default, "(k) {(k) -> v} -> v") 
  typesig(:default=, "(v) -> v")

  # TODO: check on default_proc
  #typesig(:default_proc, "() -> (Hash<k,v>,k) -> v")
  #typesig(:default_proc=, "((Hash<k,v>,k) -> v) -> (Hash<k,v>,k) -> v")

  typesig(:delete, "(k) -> v")
  typesig(:delete, "(k) { (k) -> u } -> u or v", :vars => [:u])
  typesig(:delete_if, "() { (k,v) -> %bool } -> Hash<k,v>")
  typesig(:delete_if, "() -> Enumerator")
  typesig(:each, "() { (k,v) -> %any } -> Hash<k,v>")
  typesig(:each, "() -> Enumerator")
  typesig(:each_pair, "() { (k,v) -> %any } -> Hash<k,v>")
  typesig(:each_pair, "() -> Enumerator")
  typesig(:each_key, "() { (k) -> %any } -> Hash<k,v>")
  typesig(:each_key, "() -> Enumerator")
  typesig(:each_value, "() { (v) -> %any } -> Hash<k,v>")
  typesig(:each_value, "() -> Enumerator")
  typesig(:empty?, "() -> %bool")
  typesig(:fetch, "(k) -> v")
  typesig(:fetch, "(k,u) -> u or v", :vars => [:u])
  typesig(:fetch, "(k) { (k) -> u } -> u or v", :vars => [:u])
  typesig(:member?, "(t) -> %bool", :vars => [:t])
  typesig(:has_key?, "(t) -> %bool", :vars => [:t])
  typesig(:key?, "(t) -> %bool", :vars => [:t])
  typesig(:has_value?, "(t) -> %bool", :vars => [:t])
  typesig(:value?, "(t) -> %bool", :vars => [:t])
  typesig(:to_s, "() -> String")
  typesig(:inspect, "() -> String")
  typesig(:invert, "() -> Hash<v,k>")
  typesig(:keep_if, "() { (k,v) -> %bool } -> Hash<k,v>")
  typesig(:keep_if, "() -> Enumerator")
  typesig(:key, "(t) -> k", :vars => [:t])
  typesig(:keys, "() -> Array<k>")
  typesig(:length, "() -> Fixnum")
  typesig(:size, "() -> Fixnum")
  typesig(:merge, "(Hash<a,b>) -> Hash<a or k, b or v>", :vars => [:a, :b])
  typesig(:merge, "(Hash<a,b>) { (k,v,b) -> v or b } -> Hash<a or k, b or v>", :vars => [:a, :b])
  # typesig(:rassoc, "(k) -> Tuple<k,v>")
  typesig(:rassoc, "(k) -> Array<k or v>")
  typesig(:rehash, "() -> Hash<k,v>")
  typesig(:reject, "() -> Enumerator")
  typesig(:reject, "() { (k,v) -> %bool } -> Hash<k,v>")
  typesig(:reject!, "() { (k,v) -> %bool } -> Hash<k,v>")
  typesig(:select, "() { (k,v) -> %bool } -> Hash<k,v>")
  typesig(:select!, "() { (k,v) -> %bool } -> Hash<k,v>")
  # typesig(:shift, "() -> Tuple<k,v>")
  typesig(:shift, "() -> Array<k or v>") 
  # typesig(:to_a, "() -> Array<Tuple<k,v>>")
  typesig(:to_a, "() -> Array<Array<k or v>>")
  typesig(:to_hash, "() -> Hash<k,v>")
  typesig(:values, "() -> Array<v>")
  typesig(:values_at, "(*k) -> Array<v>")
end
