# ######################################################################
#
# DRuby annotation language parser
# Adapted directly from DRuby source file typeAnnotationParser.mly
# Version of GitHub DRuby repo commit 0cda0264851bcdf6b301c3d7f564e9a3ee220e435
#
# ######################################################################

class Parser
  prechigh
    left COMMA
    right RARROW
    left OR
  preclow

  start entry

token OR ASSOC DOUBLE_COLON RARROW ID SYMBOL SPECIAL_ID STRING
token LPAREN RPAREN LBRACE RBRACE LBRACKET RBRACKET
token COMMA QUERY STAR
token EOF

rule

  entry:
      method_type { result = val[0] }

  method_type:
      LPAREN arg_list RPAREN block RARROW type_expr {
        result = RDL::Type::MethodType.new val[1], val[3], val[5]
      }

  arg_list:
      { result = [] }
    | arg { result = [val[0]] }
    | arg COMMA arg_list { if val[2] then result = val[2].unshift val[0] else val[0] end }
  arg:
      QUERY type_expr { result = RDL::Type::OptionalType.new val[1] }
    | STAR type_expr { result = RDL::Type::VarargType.new val[1] }
    | type_expr { result = val[0] }

  block:
      { result = nil }
    | LBRACE method_type RBRACE { result = val[1] }

  type_expr:
    single_type_expr { result = val[0] }

  # type_expr:
  #     or_type_list {
  #       list = val[0][:or_list]
  #       if(list.length > 1)
  #         result = handle_type_union(list)
  #       else
  #         # flatten if there is no union
  #         result = list[0]
  #       end
  #     }

  # or_type_list:
  #   | single_type_expr { result = {:or_list => [val[0]]} }
  #   | single_type_expr K_OR or_type_list {
  #       if is_union_type?(val[0])
  #          result = {:or_list => val[0].types.to_a + val[2][:or_list] }
  #       else 
  #          result = {:or_list => [val[0]] + val[2][:or_list] }
  #       end
  #     }

  single_type_expr:
      SYMBOL { result = RDL::Type::SymbolType.new(val[0]) }
    | ID {
      if val[0] == 'nil' then
        result = RDL::Type::NilType.new
      else
        result = RDL::Type::NominalType.new val[0]
      end
    }
    | SPECIAL_ID {
      if val[0] == '%any' then
        result = RDL::Type::TopType.new
      elsif val[0] == '%bool' then
        result = @tbool
      else
        fail "Unexpected special type identifier #{val[0]}"
      end
    }

---- header ----

require_relative 'lexer.rex'
require_relative 'types'

module RDL::Type

---- inner ----

def initialize()
  @tbool = RDL::Type::UnionType.new (RDL::Type::NominalType.new TrueClass), (RDL::Type::NominalType.new FalseClass)
  @yydebug = true
end

---- footer ----

end
