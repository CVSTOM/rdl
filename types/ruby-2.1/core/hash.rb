require_relative '../../../lib/rdl.rb'

class Hash
  extend RDL
  type_params [:k, :each_key], [:v, :each_value]

  typesig(:[], "(k) -> v")
  typesig(:[]=, "(k, v) -> v")
  typesig(:store, "(k,v) -> v")

  # TODO: Tuple does not work completely, seems like it didn't work completely in RTC
  # typesig(:assoc, "(k) -> Tuple<k,v>")
  typesig(:assoc, "(k) -> Array<k or v>")
  typesig(:clear, "() -> Hash<k,v>")
  typesig(:compare_by_identity, "() -> Hash<k,v>")
  typesig(:compare_by_identity?,  "() -> %bool")
  typesig(:default, "(?k) -> v")
  typesig(:default, "(k) {(k) -> v} -> v") 
  typesig(:default=, "(v) -> v")

  # TODO: check on default_proc
  #typesig(:default_proc, "() -> (Hash<k,v>,k) -> v")
  #typesig(:default_proc=, "((Hash<k,v>,k) -> v) -> (Hash<k,v>,k) -> v")

  typesig(:delete, "(k) -> v")
  typesig(:delete, "(k) { (k) -> u } -> u or v", :vars => [:u])
  typesig(:delete_if, "() { (k,v) -> %bool } -> Hash<k,v>")
  typesig(:delete_if, "() -> Enumerator")
  typesig(:each, "() { (k,v) -> %any } -> Hash<k,v>")
  typesig(:each, "() -> Enumerator")
  typesig(:each_pair, "() { (k,v) -> %any } -> Hash<k,v>")
  typesig(:each_pair, "() -> Enumerator")
  typesig(:each_key, "() { (k) -> %any } -> Hash<k,v>")
  typesig(:each_key, "() -> Enumerator")
  typesig(:each_value, "() { (v) -> %any } -> Hash<k,v>")
  typesig(:each_value, "() -> Enumerator")
  typesig(:empty?, "() -> %bool")
  typesig(:fetch, "(k) -> v")
  typesig(:fetch, "(k,u) -> u or v", :vars => [:u])
  typesig(:fetch, "(k) { (k) -> u } -> u or v", :vars => [:u])
  typesig(:member?, "(t) -> %bool", :vars => [:t])
  typesig(:has_key?, "(t) -> %bool", :vars => [:t])
  typesig(:key?, "(t) -> %bool", :vars => [:t])
  typesig(:has_value?, "(t) -> %bool", :vars => [:t])
  typesig(:value?, "(t) -> %bool", :vars => [:t])
  typesig(:to_s, "() -> String")
  typesig(:inspect, "() -> String")
  typesig(:invert, "() -> Hash<v,k>")
  typesig(:keep_if, "() { (k,v) -> %bool } -> Hash<k,v>")
  typesig(:keep_if, "() -> Enumerator")
  typesig(:key, "(t) -> k", :vars => [:t])
  typesig(:keys, "() -> Array<k>")
  typesig(:length, "() -> Fixnum")
  typesig(:size, "() -> Fixnum")
  typesig(:merge, "(Hash<a,b>) -> Hash<a or k, b or v>", :vars => [:a, :b])
  typesig(:merge, "(Hash<a,b>) { (k,v,b) -> v or b } -> Hash<a or k, b or v>", :vars => [:a, :b])
  # typesig(:rassoc, "(k) -> Tuple<k,v>")
  typesig(:rassoc, "(k) -> Array<k or v>")
  typesig(:rehash, "() -> Hash<k,v>")
  typesig(:reject, "() -> Enumerator")
  typesig(:reject, "() { (k,v) -> %bool } -> Hash<k,v>")
  typesig(:reject!, "() { (k,v) -> %bool } -> Hash<k,v>")
  typesig(:select, "() { (k,v) -> %bool } -> Hash<k,v>")
  typesig(:select!, "() { (k,v) -> %bool } -> Hash<k,v>")
  # typesig(:shift, "() -> Tuple<k,v>")
  typesig(:shift, "() -> Array<k or v>") 
  # typesig(:to_a, "() -> Array<Tuple<k,v>>")
  typesig(:to_a, "() -> Array<Array<k or v>>")
  typesig(:to_hash, "() -> Hash<k,v>")
  typesig(:values, "() -> Array<v>")
  typesig(:values_at, "(*k) -> Array<v>")
end
